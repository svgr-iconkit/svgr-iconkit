{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport createHandler from \"./createHandler\";\nimport PlatformConstants from \"../PlatformConstants\";\nexport var baseProps = ['id', 'enabled', 'minPointers', 'waitFor', 'simultaneousHandlers', 'shouldCancelWhenOutside', 'hitSlop', 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange'];\nexport var TapGestureHandler = createHandler({\n  name: 'TapGestureHandler',\n  allowedProps: [].concat(baseProps, ['maxDurationMs', 'maxDelayMs', 'numberOfTaps', 'maxDeltaX', 'maxDeltaY', 'maxDist', 'minPointers']),\n  config: {}\n});\nexport var FlingGestureHandler = createHandler({\n  name: 'FlingGestureHandler',\n  allowedProps: [].concat(baseProps, ['numberOfPointers', 'direction']),\n  config: {}\n});\n\nvar ForceTouchFallback = function (_React$Component) {\n  _inherits(ForceTouchFallback, _React$Component);\n\n  var _super = _createSuper(ForceTouchFallback);\n\n  function ForceTouchFallback() {\n    _classCallCheck(this, ForceTouchFallback);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ForceTouchFallback, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      console.warn('ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n\n  return ForceTouchFallback;\n}(React.Component);\n\n_defineProperty(ForceTouchFallback, \"forceTouchAvailable\", false);\n\nexport var ForceTouchGestureHandler = PlatformConstants !== null && PlatformConstants !== void 0 && PlatformConstants.forceTouchAvailable ? createHandler({\n  name: 'ForceTouchGestureHandler',\n  allowedProps: [].concat(baseProps, ['minForce', 'maxForce', 'feedbackOnActivation']),\n  config: {}\n}) : ForceTouchFallback;\nForceTouchGestureHandler.forceTouchAvailable = (PlatformConstants === null || PlatformConstants === void 0 ? void 0 : PlatformConstants.forceTouchAvailable) || false;\nexport var LongPressGestureHandler = createHandler({\n  name: 'LongPressGestureHandler',\n  allowedProps: [].concat(baseProps, ['minDurationMs', 'maxDist']),\n  config: {}\n});\n\nfunction validatePanGestureHandlerProps(props) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd\");\n  }\n\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd\");\n  }\n\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd\");\n  }\n\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd\");\n  }\n\n  if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {\n    throw new Error(\"First element of activeOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {\n    throw new Error(\"First element of activeOffsetY should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {\n    throw new Error(\"First element of failOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {\n    throw new Error(\"First element of failOffsetY should be negative, a the second one should be positive\");\n  }\n}\n\nfunction transformPanGestureHandlerProps(props) {\n  var res = _objectSpread({}, props);\n\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n\n  return transformPanGestureHandlerProps(props);\n}\n\nexport var PanGestureHandler = createHandler({\n  name: 'PanGestureHandler',\n  allowedProps: [].concat(baseProps, ['activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture']),\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd']\n});\nexport var PinchGestureHandler = createHandler({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {}\n});\nexport var RotationGestureHandler = createHandler({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {}\n});","map":{"version":3,"sources":["gestureHandlers.ts"],"names":["baseProps","TapGestureHandler","createHandler","name","allowedProps","config","FlingGestureHandler","ForceTouchFallback","React","componentDidMount","console","render","ForceTouchGestureHandler","LongPressGestureHandler","props","Array","res","validatePanGestureHandlerProps","transformPanGestureHandlerProps","PanGestureHandler","transformProps","customNativeProps","PinchGestureHandler","RotationGestureHandler"],"mappings":"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","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\n\nimport createHandler from './createHandler';\nimport PlatformConstants from '../PlatformConstants';\nimport { State } from '../State';\nimport { ValueOf } from '../typeUtils';\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = {\n  id?: string;\n  enabled?: boolean;\n  minPointers?: number;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?:\n    | number\n    // TODO(TS) take into consideration types from GestureHandler#setHitSlop\n    | Partial<\n        Record<\n          'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n          number\n        >\n      >\n    | Record<'width' | 'left', number>\n    | Record<'width' | 'right', number>\n    | Record<'height' | 'top', number>\n    | Record<'height' | 'bottom', number>;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nexport const baseProps = [\n  'id',\n  'enabled',\n  'minPointers',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport type TapGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface TapGestureHandlerProps\n  extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {\n  minPointers?: number;\n  maxDurationMs?: number;\n  maxDelayMs?: number;\n  numberOfTaps?: number;\n  maxDeltaX?: number;\n  maxDeltaY?: number;\n  maxDist?: number;\n}\n\nexport type TapGestureHandler = typeof TapGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const TapGestureHandler = createHandler<\n  TapGestureHandlerProps,\n  TapGestureHandlerEventPayload\n>({\n  name: 'TapGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'maxDurationMs',\n    'maxDelayMs',\n    'numberOfTaps',\n    'maxDeltaX',\n    'maxDeltaY',\n    'maxDist',\n    'minPointers',\n  ] as const,\n  config: {},\n});\n\nexport type FlingGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface FlingGestureHandlerProps\n  extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {\n  direction?: number;\n  numberOfPointers?: number;\n}\n\nexport type FlingGestureHandler = typeof FlingGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const FlingGestureHandler = createHandler<\n  FlingGestureHandlerProps,\n  FlingGestureHandlerEventPayload\n>({\n  name: 'FlingGestureHandler',\n  allowedProps: [...baseProps, 'numberOfPointers', 'direction'] as const,\n  config: {},\n});\n\nclass ForceTouchFallback extends React.Component {\n  static forceTouchAvailable = false;\n  componentDidMount() {\n    console.warn(\n      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'\n    );\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nexport type ForceTouchGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  force: number;\n};\n\nexport interface ForceTouchGestureHandlerProps\n  extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {\n  minForce?: number;\n  maxForce?: number;\n  feedbackOnActivation?: boolean;\n}\n\nexport type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {\n  forceTouchAvailable: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const ForceTouchGestureHandler = PlatformConstants?.forceTouchAvailable\n  ? createHandler<\n      ForceTouchGestureHandlerProps,\n      ForceTouchGestureHandlerEventPayload\n    >({\n      name: 'ForceTouchGestureHandler',\n      allowedProps: [\n        ...baseProps,\n        'minForce',\n        'maxForce',\n        'feedbackOnActivation',\n      ] as const,\n      config: {},\n    })\n  : ForceTouchFallback;\n\n(ForceTouchGestureHandler as ForceTouchGestureHandler).forceTouchAvailable =\n  PlatformConstants?.forceTouchAvailable || false;\n\nexport type LongPressGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface LongPressGestureHandlerProps\n  extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {\n  minDurationMs?: number;\n  maxDist?: number;\n}\n\nexport type LongPressGestureHandler = typeof LongPressGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const LongPressGestureHandler = createHandler<\n  LongPressGestureHandlerProps,\n  LongPressGestureHandlerEventPayload\n>({\n  name: 'LongPressGestureHandler',\n  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'] as const,\n  config: {},\n});\n\nfunction validatePanGestureHandlerProps(props: PanGestureHandlerProps) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props: PanGestureHandlerProps) {\n  type InternalPanGHKeys =\n    | 'activeOffsetXStart'\n    | 'activeOffsetXEnd'\n    | 'failOffsetXStart'\n    | 'failOffsetXEnd'\n    | 'activeOffsetYStart'\n    | 'activeOffsetYEnd'\n    | 'failOffsetYStart'\n    | 'failOffsetYEnd';\n  type PanGestureHandlerInternalProps = PanGestureHandlerProps &\n    Partial<Record<InternalPanGHKeys, number>>;\n\n  const res: PanGestureHandlerInternalProps = { ...props };\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props: PanGestureHandlerProps) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n\nexport type PanGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  translationX: number;\n  translationY: number;\n  velocityX: number;\n  velocityY: number;\n};\n\nexport interface PanGestureHandlerProps\n  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {\n  /** @deprecated  use activeOffsetX*/\n  minDeltaX?: number;\n  /** @deprecated  use activeOffsetY*/\n  minDeltaY?: number;\n  /** @deprecated  use failOffsetX*/\n  maxDeltaX?: number;\n  /** @deprecated  use failOffsetY*/\n  maxDeltaY?: number;\n  /** @deprecated  use activeOffsetX*/\n  minOffsetX?: number;\n  /** @deprecated  use failOffsetY*/\n  minOffsetY?: number;\n  activeOffsetY?: number | number[];\n  activeOffsetX?: number | number[];\n  failOffsetY?: number | number[];\n  failOffsetX?: number | number[];\n  minDist?: number;\n  minVelocity?: number;\n  minVelocityX?: number;\n  minVelocityY?: number;\n  minPointers?: number;\n  maxPointers?: number;\n  avgTouches?: boolean;\n  enableTrackpadTwoFingerGesture?: boolean;\n}\n\nexport type PanGestureHandler = typeof PanGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PanGestureHandler = createHandler<\n  PanGestureHandlerProps,\n  PanGestureHandlerEventPayload\n>({\n  name: 'PanGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'activeOffsetY',\n    'activeOffsetX',\n    'failOffsetY',\n    'failOffsetX',\n    'minDist',\n    'minVelocity',\n    'minVelocityX',\n    'minVelocityY',\n    'minPointers',\n    'maxPointers',\n    'avgTouches',\n    'enableTrackpadTwoFingerGesture',\n  ] as const,\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: [\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'failOffsetYStart',\n    'failOffsetYEnd',\n    'failOffsetXStart',\n    'failOffsetXEnd',\n  ],\n});\n\nexport type PinchGestureHandlerEventPayload = {\n  scale: number;\n  focalX: number;\n  focalY: number;\n  velocity: number;\n};\n\nexport interface PinchGestureHandlerProps\n  extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {}\n\nexport type PinchGestureHandler = typeof PinchGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PinchGestureHandler = createHandler<\n  PinchGestureHandlerProps,\n  PinchGestureHandlerEventPayload\n>({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n\nexport type RotationGestureHandlerEventPayload = {\n  rotation: number;\n  anchorX: number;\n  anchorY: number;\n  velocity: number;\n};\n\nexport interface RotationGestureHandlerProps\n  extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {}\n\nexport type RotationGestureHandler = typeof RotationGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const RotationGestureHandler = createHandler<\n  RotationGestureHandlerProps,\n  RotationGestureHandlerEventPayload\n>({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n"]},"metadata":{},"sourceType":"module"}